---
title: Authentication
description: Secure authentication using the session API and authentication starters.
---

Our framework provides an API for maintaining sessions, and two starters to help you get started with using these sessions for authentication:

1. **[Sessions Starter](https://github.com/redwoodjs/sdk/blob/main/starters/sessions/README.md)** â€“ Basic session management boilerplate, letting you implement your own authentication logic
2. **[Passkey Starter](https://github.com/redwoodjs/sdk/blob/main/starters/passkey-auth/README.md)** â€“ A complete implementation using passkey-based authentication

## ðŸ›  Session State Management

The session API follows the familiar pattern of storing session IDs in cookies, but with a key difference: instead of a traditional database, session data is stored in Durable Objects for real-time access across regions.

You implement your own DO to store session data, giving you control over:

- Session data structure
- Session lifecycle and validation logic
- Integration with your app's authentication flow

Both starters include [reference Session DO implementations](https://github.com/redwoodjs/sdk/blob/main/starters/sessions/src/session/durableObject.ts) to use as a starting point.

```tsx
import { defineDurableSession } from "redwoodsdk/session";

export const session = defineDurableSession({
  secretKey: process.env.SECRET_KEY,
  sessionDurableObject: env.SESSION_DURABLE_OBJECT, // Your custom DO implementation
});
```

#### `sessions.load(request)`

Used in your worker middleware to load session data into the request context:

```tsx:worker.tsx
import { defineApp } from "redwoodsdk/worker";
import { sessions } from './lib/session';

export default defineApp<Context>([
  setCommonHeaders(),
  async ({ ctx, request }) => {
    ctx.session = await sessions.load(request);
  },
  layout(Document, [/* routes */]),
]);
```

If adding the session durable object to a new project, you'll need to specify it in your `wrangler.jsonc`.

```json:wrangler.jsonc
  "durable_objects": {
    "bindings": [
      {
        // needs to match `defineDurableSession({ sessionDurableObject: env.SESSION_DURABLE_OBJECT, ... })`
        "name": "SESSION_DURABLE_OBJECT",
        // needs to match the name of the durable object class
        "class_name": "SessionDurableObject",
      },
    ],
  },
```

You'll also need to export the durable object class in your worker entry point script (e.g. `worker.tsx`)

```tsx:worker.tsx
export { SessionDurableObject } from "./session/durableObject";
```

#### `sessions.save(headers, sessionData)`

Used in server actions to save session state (e.g. after authentication):

```tsx:app/auth/actions.ts
'use server'

async function handleLogin(ctx?: RouteContext) {
  // ... authentication logic ...

  await sessions.save(ctx!.headers, {
    userId: user.id,
  });
}
```

## ðŸ”‘ Passkey Authentication

The passkey starter implements passwordless authentication using public-private key pairs.

### **How It Works**

1. Registration creates a public-private key pair
2. Your server stores the public key
3. Login verifies a challenge using the private key (stored on user's device)

### **Security Considerations**

The starter uses usernames instead of emails to:

- Prevent user enumeration attacks
- Avoid requiring email verification
- Use credential IDs for lookups instead of personal data

Add email verification if your app requires verified identities.

### **Bot Protection**

Since the passkey starter allows multiple accounts per username and has no email verification step, it needs protection against registration spam. While Cloudflare's built in bot detection will identify and block malicious patterns over time, Turnstile provides immediate verification before registration:

1. Load Turnstile via `<TurnstileScript />`
2. During registration on client side: generate a challenge token with `useTurnstile()`
3. In action handler on worker side: verify the token server-side with `verifyTurnstileToken()`
