---
title: Authentication
description: Secure authentication using the session API and authentication starters.
---

Our framework provides an API for maintaining sessions, and two starters to help you get started with using these sessions for authentication:

1. **[Sessions Starter](https://github.com/redwoodjs/sdk/blob/main/starters/sessions/README.md)** â€“ Basic session management boilerplate, letting you implement your own authentication logic
2. **[Passkey Starter](https://github.com/redwoodjs/sdk/blob/main/starters/passkey-auth/README.md)** â€“ A complete implementation using passkey-based authentication

## ðŸ›  Session State Management

The session API follows the familiar pattern of storing session IDs in cookies, but with a key difference: instead of a traditional database, session data is stored in Durable Objects for real-time access across regions.

You implement your own DO to store session data, giving you control over:

- Session data structure
- Session lifecycle and validation logic
- Integration with your app's authentication flow

Both starters include [reference Session DO implementations](https://github.com/redwoodjs/sdk/blob/main/starters/sessions/src/session/durableObject.ts) to use as a starting point.

```tsx
import { defineDurableSession } from "redwoodsdk/session";

export const session = defineDurableSession({
  secretKey: process.env.SECRET_KEY,
  sessionDurableObject: env.SESSION_DURABLE_OBJECT, // Your custom DO implementation
});
```

#### `sessions.load(request)`

Used in your worker middleware to load session data into the request context:

```tsx:worker.tsx
import { defineApp } from "redwoodsdk/worker";
import { sessions } from './lib/session';

export default defineApp<Context>([
  setCommonHeaders(),
  async ({ ctx, request }) => {
    ctx.session = await sessions.load(request);
  },
  layout(Document, [/* routes */]),
]);
```

#### `sessions.save(headers, sessionData)`

Used in server actions to save session state (e.g. after authentication):

```tsx:app/auth/actions.ts
'use server'

async function handleLogin(ctx?: RouteContext) {
  // ... authentication logic ...

  await sessions.save(ctx!.headers, {
    userId: user.id,
  });
}
```

## Setting up sessions on new projects

If adding the session durable object to a new project, first define your session durable object. For an example, check out the [reference Session DO implementation](https://github.com/redwoodjs/sdk/blob/main/starters/sessions/src/session/durableObject.ts):

```ts:session/durableObject.ts
export class SessionDurableObject extends DurableObject {
  getSession(): Promise<GetSessionResult<Session>> {
    ...
  }
  saveSession(data: SessionInputData): Promise<Session> {
    ...
  }
  revokeSession(): void {
    ...
  }
}
```

Then, set up a session store that uses the durable object:

```session/store.ts
import { defineDurableSession } from "redwoodsdk/auth";

export let sessions: ReturnType<typeof createSessionStore>;

const createSessionStore = (env: Env) =>
  defineDurableSession({
    // Define the secret key using `wrangler secret put` for deployments, and `.env` for development
    secretKey: env.SECRET_KEY,
    sessionDurableObject: env.SESSION_DURABLE_OBJECT,
  });

export const setupSessionStore = (env: Env) => {
  sessions = createSessionStore(env);
  return sessions;
};
```

The session store requires a secret key (`env.SECRET_KEY`) to use for signing session ids (in order to verify that the worker issued them before DO instances are created).

For development, set the secret key using `.env`:

```env:.env
SECRET_KEY=abc
```

For deployments, set the secret key using `wrangler secret put`:

```bash
npx wrangler secret put SECRET_KEY
```

Then, reference the DO it in your `wrangler.jsonc`.

```json:wrangler.jsonc
  "durable_objects": {
    "bindings": [
      {
        // needs to match `defineDurableSession({ sessionDurableObject: env.SESSION_DURABLE_OBJECT, ... })`
        "name": "SESSION_DURABLE_OBJECT",
        // needs to match the name of the durable object class
        "class_name": "SessionDurableObject",
      },
    ],
  },
```

Now, export the durable object class in your worker entry point script (`worker.tsx`)

```tsx:worker.tsx
export { SessionDurableObject } from "./session/durableObject";
```

Finally, initialise the session store defined above in your `worker.tsx` entry point:

```tsx:worker.tsx
export default defineApp<Context>([
  // ...
  async ({ env, ctx, request }) => {
    setupSessionStore(env);
  },
])
```

You're now ready to use your session store!

```
export default defineApp<Context>([
  async ({ env, ctx, request }) => {
    setupSessionStore(env);
    ctx.session = await sessions.load(request);
  },
]);
```

## ðŸ”‘ Passkey Authentication

The passkey starter implements passwordless authentication using public-private key pairs.

### **How It Works**

1. Registration creates a public-private key pair
2. Your server stores the public key
3. Login verifies a challenge using the private key (stored on user's device)

### **Security Considerations**

The starter uses usernames instead of emails to:

- Prevent user enumeration attacks
- Avoid requiring email verification
- Use credential IDs for lookups instead of personal data

Add email verification if your app requires verified identities.

### **Bot Protection**

Since the passkey starter allows multiple accounts per username and has no email verification step, it needs protection against registration spam. While Cloudflare's built in bot detection will identify and block malicious patterns over time, Turnstile provides immediate verification before registration:

1. Load Turnstile via `<TurnstileScript />`
2. During registration on client side: generate a challenge token with `useTurnstile()`
3. In action handler on worker side: verify the token server-side with `verifyTurnstileToken()`
