---
title: Request Handling & Routing
description: Like air traffic control, but for requests.
---

import { Aside, Tabs, TabItem, LinkCard } from "@astrojs/starlight/components";

The request/response paradigm is at the heart of web development - when a browser makes a request, your server needs to respond with content. RedwoodSDK makes this easy with the `defineApp` function, which lets you elegantly handle incoming requests and return the right responses.

## Request Context

At the core of RedwoodSDK is the `requestContext` object, which provides access to everything you need to handle requests and build responses. This shared context is available throughout your application - in middleware, route handlers, and React Server Components.

```tsx
import { requestContext } from "@redwoodjs/sdk/worker";

// Access request context anywhere in your application
const { request, params, env, data, cf } = requestContext;
```

The `requestContext` object includes:

1. `request`: The [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object representing the incoming HTTP request
2. `params`: Parameters extracted from the URL based on your route patterns (e.g., `/users/:id` â†’ `params.id`)
3. `env`: Your Cloudflare environment, including bindings to Durable Objects, D1, etc.
4. `data`: A mutable object for sharing data between middleware and handlers
5. `cf`: Cloudflare's [Execution Context API](https://developers.cloudflare.com/workers/runtime-apis/context/) methods, e.g. `waitUntil()`

## Defining Your App

The `defineApp` function takes an array of middleware and route handlers that are executed in the order they are defined.

```tsx title="src/worker.tsx"
import { defineApp } from "@redwoodjs/sdk/worker";
import { route } from "@redwoodjs/sdk/router";
import { requestContext } from "@redwoodjs/sdk/worker";

export default defineApp([
  // Middleware
  function middleware() { 
    const { data } = requestContext;
    // Modify data here
  },
  // Request Handlers
  route("/", function handler() {
    return new Response("Hello, world!")
  }),
  route("/ping", function handler() {
    return new Response("Pong!")
  }),
]);
```

## Middleware & Data

Middleware runs before any routes are matched, allowing you to set up the request context. You can specify multiple middleware functions, which will be executed in order.

The `data` object in `requestContext` is where you store and share information between middleware, route handlers, and React Server Components:

```tsx title="src/worker.tsx"
import { defineApp } from "@redwoodjs/sdk/worker";
import { route } from "@redwoodjs/sdk/router";
import { requestContext } from "@redwoodjs/sdk/worker";

defineApp([
  // Add user data to context if authenticated
  async function authMiddleware() {
    const { data } = requestContext;
    const userId = await getCurrentUser();
    if (userId) {
      data.user = await db.user.find({ id: userId });
    }
  },
  // Use that data in routes
  route("/profile", function handler() {
    const { data } = requestContext;
    if (!data.user) {
      return new Response("Unauthorized", { status: 401 });
    }
    return <UserProfile />;
  }),
]);
```

## Matching Patterns

Routes are matched in the order they are defined. You define routes using the `route` function. Trailing slashes are optional and normalized internally.

```tsx title="src/worker.tsx" mark={4}
import { route } from "@redwoodjs/sdk/router";

defineApp([
  route("/match-this", () => new Response("Hello, world!"))
])

---
`route` parameters:
1. The matching pattern string
2. The request handler function
---
```

There are three matching patterns:

#### Static

Match exact pathnames.

```tsx
route("/", ...)
route("/about", ...)
route("/contact", ...)
```

#### Parameter

Match dynamic segments marked with a colon (`:`). The values are available via `requestContext.params` (`requestContext.params.id` and `requestContext.params.groupId`).

```tsx
route("/users/:id", ...)
route("/users/:id/edit", ...)
route("/users/:id/addToGroup/:groupId", ...)
```

#### Wildcard

Match all remaining segments after the prefix, the values are available via `requestContext.params.$0`, `requestContext.params.$1`, etc.

```tsx
route("/files/*", ...)
route("/files/*/preview", ...)
route("/files/*/download/*", ...)
```

## Request Handlers

The request handler is a function, or array of functions (See [Interruptors](#interruptors)), that are executed when a request is matched.

```tsx title="src/worker.tsx" mark={4-9}
import { route } from "@redwoodjs/sdk/router";
import { requestContext } from "@redwoodjs/sdk/worker";

defineApp([
  route("/a-standard-response", () => {
    return new Response("Hello, world!")
  }),
  route('/a-jsx-response', () => {
    return <div>Hello, JSX world!</div>
  }),
])

---
Return values:
- `Response`: A standard response object.
- `JSX`: A React component, which is statically rendered to HTML on the server, streamed to the client, and then hydrated on the client side.
---
```

### Interruptors

Interruptors are an array of functions that are executed in sequence for each matched request. They can be used to modify the request, context, or to short-circuit the response. A typical use-case is to check for authentication on a per-request basis.

```tsx title="src/worker.tsx" mark={5-10, 13} collapse={1-2}
import { defineApp } from "@redwoodjs/sdk/worker";
import { route } from "@redwoodjs/sdk/router";
import { EditBlogPage } from "src/pages/blog/EditBlogPage";

function isAuthenticated() {
  const { data } = requestContext;
  if (!data.user) {
    return new Response("Unauthorized", { status: 401 });
  }
}

defineApp([
  route("/blog/:slug/edit", [isAuthenticated, EditBlogPage])
])

---
For the `/blog/:slug/edit` route, the `isAuthenticated` function will be executed first. If the user is not authenticated, the response will be a 401 Unauthorized. If the user is authenticated, the `EditBlogPage` component will be rendered. The `isAuthenticated` function can be shared across multiple routes.
---
```

## Documents

Documents are how you define the "shell" of your application's html: the `<html>`, `<head>`, `<meta>` tags, scripts, stylesheets, `<body>`, and where in the `<body>` your actual page content is rendered. In RedwoodSDK, you tell it which document to use with the `render()` function in `defineApp`.

```tsx title="src/worker.tsx" "document"
import { defineApp } from "@redwoodjs/sdk/worker";
import { route, render } from "@redwoodjs/sdk/router";

import { Document } from "@/pages/Document";
import { HomePage } from "@/pages/HomePage";

export default defineApp([
  render(Document, [route("/", HomePage)])
]);

---
The `render` function takes a React component and an array of route handlers. The document will be applied to all the routes that are passed to it.

This component will be rendered on the server side when the page loads. When defining this component, you'd add:
* Your application's stylesheets and scripts
* A mount point for your page content (`id="root"` in the code below): this is where your actual page will be rendered - the "dynamic stuff" which updates using React Server Components.
---
```

```tsx title="src/pages/Document.tsx" mark={7}
export const Document = () => {
  const { children } = requestContext;
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <script type="module" src="/src/client.tsx"></script>
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

<Aside type="caution" title="Client Side Hydration">
  You must include the client side hydration script in your document, otherwise
  the React components will not be hydrated.
</Aside>
